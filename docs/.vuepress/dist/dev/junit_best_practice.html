<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>聊一聊怎么编写好的单元测试 | 欢迎访问supengfei007.com</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Happy coding">
    <link rel="preload" href="/assets/css/0.styles.0baa0dff.css" as="style"><link rel="preload" href="/assets/js/app.d2d7004c.js" as="script"><link rel="preload" href="/assets/js/2.c806fa72.js" as="script"><link rel="preload" href="/assets/js/6.46361e8b.js" as="script"><link rel="prefetch" href="/assets/js/3.7ff0e151.js"><link rel="prefetch" href="/assets/js/4.3f11aa2f.js"><link rel="prefetch" href="/assets/js/5.9e74c3c6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0baa0dff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">欢迎访问supengfei007.com</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item ant-menu-item-selected"><a href="/dev/junit_best_practice.html" aria-current="page" class="router-link-exact-active router-link-active">
          Junit
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="https://segmentfault.com/a/1190000016333850" target="_blank">
          帮忙
          <i aria-label="icon: link" class="anticon anticon-link"><svg viewBox="64 64 896 896" focusable="false" data-icon="link" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M574 665.4a8.03 8.03 0 0 0-11.3 0L446.5 781.6c-53.8 53.8-144.6 59.5-204 0-59.5-59.5-53.8-150.2 0-204l116.2-116.2c3.1-3.1 3.1-8.2 0-11.3l-39.8-39.8a8.03 8.03 0 0 0-11.3 0L191.4 526.5c-84.6 84.6-84.6 221.5 0 306s221.5 84.6 306 0l116.2-116.2c3.1-3.1 3.1-8.2 0-11.3L574 665.4zm258.6-474c-84.6-84.6-221.5-84.6-306 0L410.3 307.6a8.03 8.03 0 0 0 0 11.3l39.7 39.7c3.1 3.1 8.2 3.1 11.3 0l116.2-116.2c53.8-53.8 144.6-59.5 204 0 59.5 59.5 53.8 150.2 0 204L665.3 562.6a8.03 8.03 0 0 0 0 11.3l39.8 39.8c3.1 3.1 8.2 3.1 11.3 0l116.2-116.2c84.5-84.6 84.5-221.5 0-306.1zM610.1 372.3a8.03 8.03 0 0 0-11.3 0L372.3 598.7a8.03 8.03 0 0 0 0 11.3l39.6 39.6c3.1 3.1 8.2 3.1 11.3 0l226.4-226.4c3.1-3.1 3.1-8.2 0-11.3l-39.5-39.6z"></path></svg></i></a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          GitHub
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><!----> <!----></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h1 id="聊一聊怎么编写好的单元测试"><a href="#聊一聊怎么编写好的单元测试" class="header-anchor">#</a> 聊一聊怎么编写好的单元测试</h1> <h3 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h3> <p>维基百科上单元测试的定义是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。</p> <p>对于java应用来说，单元测试是对一个java类的方法级别测试。今天我们来聊下怎么编写优雅的单元测试的一些方法论和最佳实践。</p> <h3 id="为什么需要单元测试"><a href="#为什么需要单元测试" class="header-anchor">#</a> 为什么需要单元测试</h3> <ol><li>单元测试能够以较低的成本，来验证代码逻辑的正确性。它也能很大程度上提高代码质量。</li> <li>降低测试成本。 虽然编写单测会花费我们一些功夫，但是Bug发现的越早，修复的代价越小。另外如果代码有良好的单元测试，集成测试和系统测试就只需要关注功能和流程方面的问题，回归测试成本也大幅减少。</li> <li>重构代码时提升信心。单测可以确保重构后的代码没有改变原来的逻辑，如果逻辑发生来改变，会有失败的用例提示你。</li> <li>有助于理解代码的逻辑。测试用例很直观的可以看出待测试方法想要表达的逻辑，很多著名的框架都提供对应的测试用例，如Spring，Guava。</li> <li>最后就是公司的研发流程规范有覆盖率要求。</li></ol> <h3 id="单元测试的时机"><a href="#单元测试的时机" class="header-anchor">#</a> 单元测试的时机</h3> <ul><li>刚写好类的方法时，这是最熟悉这段业务逻辑的时候，赶紧写一个Junit来验证下自己的成果。</li> <li>重构代码之前，重构最怕的是是什么，当然是改出问题来。一个良好的单测能让你再重构的时候更从容一些。</li> <li>覆盖率不够的时候，需要我们补测试用例到达目标值，经验值是70%。当然提升覆盖率也不是越高越好。太高的指标会导致开发人员采用Hack的方式来提高覆盖率。</li></ul> <h3 id="怎么写单元测试"><a href="#怎么写单元测试" class="header-anchor">#</a> 怎么写单元测试</h3> <p>3A（Arrange、Act、Assert）模式是编写待测试方法的单元测试的常用方法。一个Junit典型结构如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>@Test
public void getCategoryPath() {
    // 准备数据
    Category zj = new Category();
    zj.setCategoryId(1000L);
    zj.setParentId(100L);
    zj.setCategoryName(&quot;张江&quot;);
    Mockito.when(knowledgeCategoryDao.queryAllKnowledgeCategory()).thenReturn(mockData());
    Mockito.when(knowledgeCategoryDao.queryByPk(1000L)).thenReturn(zj);
    
    // 调用测试方法
    String path = categoryService.getCategoryPath(1000L);
    
    // 断言
    Assert.assertThat(path, is(&quot;上海市/浦东新区/张江&quot;));
}
</code></pre></div><h4 id="arrange-准备"><a href="#arrange-准备" class="header-anchor">#</a> Arrange，准备</h4> <p>准备阶段构造调⽤所需要的外部环境，如数据，临时变量，网路请求，环境变量等。这里是挑战最大的部分，引入测试替身(Test Double)能够显著降低这部分的难度。</p> <h5 id="测试替身"><a href="#测试替身" class="header-anchor">#</a> 测试替身</h5> <table><thead><tr><th>测试替身</th> <th>定义</th> <th>使用场景</th></tr></thead> <tbody><tr><td>Dummy</td> <td>只用来传参从不被真正使用</td> <td>填充参数列表，消除编译错误</td></tr> <tr><td>Fake</td> <td>一个可以work的简单实现，不能用于生产</td> <td>H2，内存中执行CRUD操作</td></tr> <tr><td>Stub</td> <td>有实际实现的对象替换一部分功能的程序</td> <td>当从数据库查询时，直接返回预定义好的数据</td></tr> <tr><td>Mock</td> <td>创建一个虚假的对象，满足预定的参数它会返回预定结果</td> <td>第三单接口，when x then y</td></tr></tbody></table> <p><em>这里的Stub是指用来替换一部分功能的程序段。桩程序可以用来模拟已有程序的行为（比如一个远端机器的过程）或是对将要开发的代码的一种临时替代。</em></p> <p>Stub 的典型应用场景即是当某个对象需要从数据库抓取数据时，它并不是真实的从数据库抓取数据，而是直接返回预定义好的数据。</p> <p>Stub和Mock微妙的区别</p> <div class="language- extra-class"><pre class="language-text"><code>// code in StubDao
public Category queryByPk(Long id) {
    return new Category(id);
}
CategoryDao categoryDao = new StubDao();
Category category = categoryDao.queryByPk(2L);
</code></pre></div><p>Mock实例:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">CategoryDao</span> categoryDao <span class="token operator">=</span> <span class="token class-name">Mockito</span><span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token class-name">CategoryDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Mockito</span><span class="token punctuation">.</span><span class="token function">when</span><span class="token punctuation">(</span>categoryDao<span class="token punctuation">.</span><span class="token function">queryByPk</span><span class="token punctuation">(</span><span class="token number">2L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>了解更多请参考<a href="https://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="noopener noreferrer">Martin Fowler 的 Mocks Aren't Stubs
<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="act-执行要测试的方法。"><a href="#act-执行要测试的方法。" class="header-anchor">#</a> Act，执行要测试的方法。</h4> <h4 id="assert-断言"><a href="#assert-断言" class="header-anchor">#</a> Assert，断言</h4> <p>最后判断结果是否符合预期，推荐Hamcrest, 它提供符合直觉，更好的可读性的断言功能。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;SPF&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Henan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertThat</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token function">hasProperty</span><span class="token punctuation">(</span><span class="token string">&quot;address&quot;</span><span class="token punctuation">,</span> <span class="token function">equalTo</span><span class="token punctuation">(</span><span class="token string">&quot;Henan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> collection <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cd&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ef&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertThat</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> <span class="token function">hasItem</span><span class="token punctuation">(</span><span class="token string">&quot;cd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertThat</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cd&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ef&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h3 id="什么是好的单元测试"><a href="#什么是好的单元测试" class="header-anchor">#</a> 什么是好的单元测试</h3> <p>好的单元测试必须遵守AIR原则，感觉像空气（AIR）一样并不存在。</p> <ul><li><p>A：Automatic（自动化）
全自动执行，无人为干预和交互。一般是在CI/CD流程中。</p></li> <li><p>I: Independent（独立性）
要求单测无调用关系，无调用顺序。</p></li> <li><p>R: Repeatable（可重复）。
是指不能受到外界环境的影响</p></li></ul> <p>除了AIR这些原则之外，下面是我们实践中总结的一些经验:</p> <ul><li><p>起个好名字
好的命名能让单测更容易理解。为测试用例起个好名字其实没有为变量或方法取名那么困难，一般是以我们测试的方法同名，如果测试用例有2个分支的话，最好写2个测试用例，并在方法名上加以区分，例如doSomethingWithA, doSomethingWithB。</p></li> <li><p>简单
是指测试用例简单明了，避免单测本身包含复杂的逻辑。</p></li> <li><p>完整
是要求用执行正常场景和异常场景，边界等，覆盖不同的代码分支。</p></li> <li><p>快速
执行速度要快，一般不要超过1秒，试想下如果100个用例，每个用例跑1分钟的画面。</p></li></ul> <h3 id="最佳实践-提倡和不提倡的"><a href="#最佳实践-提倡和不提倡的" class="header-anchor">#</a> 最佳实践，提倡和不提倡的</h3> <p>几乎所有的开发同学同学都写过单元测试，在编写测试用例的时候是否遇到测试代码难以下手，测试结果不稳定，执行时间长这些问题呢？</p> <p>这些问题或许能从下面的最佳实践中找到解决方法。</p> <h3 id="do"><a href="#do" class="header-anchor">#</a> DO</h3> <ol><li><p>只测要测试的方法。试着这样思考，输入是 x 和 y，输出会是 z 吗？而不是
如果我的输入是 x 和 y，那么这个方法会先调用 A 类，然后调用 B 类，接着输出 A 类和 B 类返回值相加的结果吗？</p></li> <li><p>Mock第三方依赖，如Mockito。这会使测试更稳定，且迅速。
比如用户还款方法，依赖支付接口，我们并不希望发生一笔支付交易,可以使用使用Mockito创建一个假的支付接口，这样就可以全面控制它了。在下面的例子里，返回支付成功。</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>PayClient payClient = Mockito.Mock(PayClient.class);
Mockito.when(payClient.tx(txRequest)).thenReturn(true);
UserRepayService userRepayService = new UserRepayServiceImpl(payClient);
</code></pre></div><ol start="3"><li>使用最细粒度的断言。对比下面2个断言，很明显上面的断言更明确。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>Assert.assertThat(items, hasItems(&quot;one&quot;, &quot;two&quot;));

Assert.assertThat(items, not(empty()));
</code></pre></div><ol start="4"><li><p>编写容易测试的代码，下面是一些建议:</p> <ul><li>方法的行数要少</li> <li>避免静态代码块初始化类</li> <li>依赖注入避字段注入，推荐构造函数注入。我们项目中Idea会提示<em>Field injection is not recommended</em>。Field Injection的问题这里不做讨论，它还导致依赖服务很难被注入。
如果采用构造器注入的话，我们可以很容易的new一个依赖传入待测试的类里。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>public class UserRepayServiceImplTest {
    // 构建待测试实例
    private PayTradeInfoClient payTradeInfoClient = Mockito.mock(PayTradeInfoClient.class);
    private ThorQueryClient thorQueryClient = Mockito.mock(ThorQueryClient.class);

    private UserRepayServiceImpl userRepayService = new UserRepayServiceImpl(this.payTradeInfoClient, this.thorQueryClient);
    
    @Test
    // 省略测试用例代码
}
</code></pre></div><p>如果使用Field injection也不用担心，我们可以通过反射方式设置字段。</p> <div class="language- extra-class"><pre class="language-text"><code>    MockitoAnnotations.initMocks(this);
    ReflectionTestUtils.setField(categoryService, &quot;knowledgeCategoryDao&quot;, knowledgeCategoryDao);
</code></pre></div><p>对比下下面2个类，哪个更容易测试? 它们的名字或许会给你答案。</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>    public class UnTestableDemo {
        public void writeUserName(int id) {
            String userName = App.getDatabaseManager().getUserDatabase().getUserName(id);
            try (FileWriter writer = new FileWriter(&quot;user.txt&quot;)) {
                writer.write(userName);
            }
        }
    }
    
    public class EasyTestableDemo {
        private final UserDatabase userDatabase;
  
        public MyClass(final UserDatabase userDatabase) {
            this.userDatabase = userDatabase
        }
      
        public void writeUserName(int id, Writer writer) {
            String userName = this.userDatabase.getUserName(id);
            writer.write(userName);
      }
    }
    
</code></pre></div><p><strong>tips</strong> 在Idea中光标在要测试的类上，使用Alt + Enter可以快速创建Junit。</p> <h4 id="not-do"><a href="#not-do" class="header-anchor">#</a> NOT DO</h4> <ul><li>不依赖数据库，如果必须的话，使用H2模拟一个。测试环境的数据库有可能会被修改，而且执行时间也会加长。</li> <li>不要mock值对象。</li> <li>不要怕测试用例代码重复，它们只是测试代码。</li> <li>不要skip用例，被skip的测试用例不会执行。skip失败的用例只会把问题掩盖。</li> <li>避免使用SpringTestRunner，SpringTestRunner有什么问题呢？</li></ul> <ol><li>慢，加载Spring一般要1min左右，如果Test Case多的话，跑完全部话费的时间太长，而且随着用例次数的增长线性增长。</li> <li>引入额外依赖，创建太多不需要的bean，有可能因为不相关的bean的创建失败，导致整个用例失败。</li></ol> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>以上我们谈了单元测试对提升代码质量，提高测试效率等好处，还有实践中遇到的问题和解决方法。希望能对大家编写好的单元测试有所帮助。</p> <p>Happy Testing, Happier Coding</p> <p>参考资料:<br>
https://github.com/mockito/mockito/wiki/How-to-write-good-tests
<br>
https://mp.weixin.qq.com/s/okmWMOeBm7cCIZ1zzFr4KQ
<br>
https://stackoverflow.com/a/69263/2299922
<br>
《Java程序员修炼之道》</p> <h3 id="作者介绍"><a href="#作者介绍" class="header-anchor">#</a> 作者介绍</h3> <p>SPF007, 信也科技中台研发催收部门研发一枚，主要负责客服系统的研发。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d2d7004c.js" defer></script><script src="/assets/js/2.c806fa72.js" defer></script><script src="/assets/js/6.46361e8b.js" defer></script>
  </body>
</html>